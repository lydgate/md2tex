#!/usr/bin/env python3
"""
Markdown to LaTeX Book Converter
Converts 51 Markdown files to a professional book-style PDF using Minion Pro font
Optimized for A4 paper with two-column layout for maximum readability
"""

import os
import re
import sys
import glob
import argparse
from pathlib import Path
import subprocess

def escape_latex(text):
    """Escape special LaTeX characters in text, but preserve LaTeX commands"""
    # Dictionary of LaTeX special characters and their escaped versions
    latex_chars = {
        '&': r'\&',
        '%': r'\%',
        '$': r'\$',
        '#': r'\#',
        '^': r'\textasciicircum{}',
        '_': r'\_',
        '~': r'\textasciitilde{}',
    }
    
    # Escape special characters (but not backslashes, braces, or LaTeX commands)
    for char, escape in latex_chars.items():
        text = text.replace(char, escape)
    
    return text

def process_markdown_line(line, use_sections=False):
    """Convert a single line of Markdown to LaTeX"""
    line = line.rstrip()
    
    # Skip empty lines (they'll be handled by paragraph spacing)
    if not line.strip():
        return ""
    
    # Headers
    if line.startswith('# '):
        title = escape_latex(line[2:].strip())
        if use_sections:
            return f"\\section{{{title}}}\n"
        else:
            return f"\\chapter{{{title}}}\n"
    elif line.startswith('## '):
        title = escape_latex(line[3:].strip())
        return f"\\subsection{{{title}}}\n"
    elif line.startswith('### '):
        title = escape_latex(line[4:].strip())
        return f"\\subsubsection{{{title}}}\n"
    elif line.startswith('#### '):
        title = escape_latex(line[5:].strip())
        return f"\\paragraph{{{title}}}\n"
    elif line.startswith('##### '):
        title = escape_latex(line[6:].strip())
        return f"\\subparagraph{{{title}}}\n"
    elif line.startswith('###### '):
        title = escape_latex(line[7:].strip())
        return f"\\subparagraph{{{title}}}\n"
    
    # Lists
    elif line.strip().startswith('- ') or line.strip().startswith('* '):
        content = escape_latex(line.strip()[2:])
        return f"\\item {content}"
    elif re.match(r'^\s*\d+\.\s+', line):
        content = escape_latex(re.sub(r'^\s*\d+\.\s+', '', line))
        return f"\\item {content}"
    
    # Code blocks
    elif line.strip().startswith('```'):
        lang = line.strip()[3:].strip()
        if lang:
            return f"\\begin{{lstlisting}}[language={lang}]"
        else:
            return "\\begin{lstlisting}"
    elif line.strip() == '```':
        return "\\end{lstlisting}\n"
    
    # Inline code
    line = re.sub(r'`([^`]+)`', r'\\texttt{\\detokenize{\1}}', line)
    
    # Bold and italic
    line = re.sub(r'\*\*\*([^*]+)\*\*\*', r'\\textbf{\\textit{\1}}', line)
    line = re.sub(r'\*\*([^*]+)\*\*', r'\\textbf{\1}', line)
    line = re.sub(r'\*([^*]+)\*', r'\\textit{\1}', line)
    line = re.sub(r'___([^_]+)___', r'\\textbf{\\textit{\1}}', line)
    line = re.sub(r'__([^_]+)__', r'\\textbf{\1}', line)
    line = re.sub(r'_([^_]+)_', r'\\textit{\1}', line)
    
    # Links - handle URLs with special characters
    def process_link(match):
        text = match.group(1)
        url = match.group(2)
        # Use \url{} for URLs to handle special characters properly
        return f'\\url{{{url}}}'
    
    line = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', process_link, line)
    
    # Handle quotes - convert to LaTeX quote conventions
    # Single quotes: 'text' -> `text'
    line = re.sub(r"'([^']*)'", r"`\1'", line)
    # Double quotes: "text" -> ``text''
    line = re.sub(r'"([^"]*)"', r"``\1''", line)
    
    # Escape remaining text and return as paragraph
    return escape_latex(line) + "\n"

def extract_yaml_front_matter(lines):
    """Extract YAML front matter from the beginning of a markdown file"""
    if not lines or not lines[0].strip().startswith('---'):
        return {}, lines
    
    # Find the end of YAML front matter
    end_index = -1
    for i, line in enumerate(lines[1:], 1):
        if line.strip() == '---':
            end_index = i
            break
    
    if end_index == -1:
        return {}, lines
    
    # Extract YAML content
    yaml_lines = lines[1:end_index]
    yaml_content = {}
    
    for line in yaml_lines:
        line = line.strip()
        if ':' in line:
            key, value = line.split(':', 1)
            key = key.strip()
            value = value.strip().strip('"\'')  # Remove quotes
            yaml_content[key] = value
    
    # Return remaining lines (after the closing ---)
    return yaml_content, lines[end_index + 1:]

def convert_markdown_file(md_file_path, use_sections=False):
    """Convert a single Markdown file to LaTeX content"""
    with open(md_file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    # Extract YAML front matter
    yaml_metadata, content_lines = extract_yaml_front_matter(lines)
    
    latex_content = []
    in_list = False
    in_ordered_list = False
    in_code_block = False
    paragraph_buffer = []
    
    for line in content_lines:
        line = line.rstrip()
        
        # Handle code blocks
        if line.strip().startswith('```'):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if in_code_block:
                latex_content.append("\\end{lstlisting}\n\n")
                in_code_block = False
            else:
                lang = line.strip()[3:].strip()
                if lang:
                    latex_content.append(f"\\begin{{lstlisting}}[language={lang}]\n")
                else:
                    latex_content.append("\\begin{lstlisting}\n")
                in_code_block = True
            continue
        
        if in_code_block:
            latex_content.append(line + "\n")
            continue
        
        # Handle empty lines
        if not line.strip():
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            continue
        
        # Handle headers
        if line.startswith('#'):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if in_list:
                latex_content.append("\\end{itemize}\n\n")
                in_list = False
            if in_ordered_list:
                latex_content.append("\\end{enumerate}\n\n")
                in_ordered_list = False
            
            latex_content.append(process_markdown_line(line, use_sections))
            continue
        
        # Handle lists
        if line.strip().startswith(('- ', '* ')):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if not in_list:
                if in_ordered_list:
                    latex_content.append("\\end{enumerate}\n\n")
                    in_ordered_list = False
                latex_content.append("\\begin{itemize}\n")
                in_list = True
            
            latex_content.append(process_markdown_line(line, use_sections) + "\n")
            continue
        
        elif re.match(r'^\s*\d+\.\s+', line):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if not in_ordered_list:
                if in_list:
                    latex_content.append("\\end{itemize}\n\n")
                    in_list = False
                latex_content.append("\\begin{enumerate}\n")
                in_ordered_list = True
            
            latex_content.append(process_markdown_line(line, use_sections) + "\n")
            continue
        
        # Close lists if we're not in a list item
        if in_list:
            latex_content.append("\\end{itemize}\n\n")
            in_list = False
        if in_ordered_list:
            latex_content.append("\\end{enumerate}\n\n")
            in_ordered_list = False
        
        # Regular paragraph content
        processed_line = process_markdown_line(line, use_sections).strip()
        if processed_line:
            paragraph_buffer.append(processed_line)
    
    # Handle remaining content
    if paragraph_buffer:
        latex_content.append(' '.join(paragraph_buffer) + "\n\n")
    
    if in_list:
        latex_content.append("\\end{itemize}\n\n")
    if in_ordered_list:
        latex_content.append("\\end{enumerate}\n\n")
    
    return ''.join(latex_content)

def create_latex_document(md_files, output_file, use_sections=False, title="Your Book Title", author="Author Name", subtitle="Subtitle or Description"):
    """Create the complete LaTeX document"""
    
    # LaTeX preamble with optimized two-column layout
    preamble = f'''\\documentclass[11pt,a4paper,oneside]{{book}}

% Font setup - Minion Pro
\\usepackage{{fontspec}}
\\setmainfont{{Minion Pro}}
\\setsansfont{{Myriad Pro}}
\\setmonofont{{Source Code Pro}}

% Page layout optimized for A4 single-sided printing
\\usepackage[
    a4paper,
    left=25mm,     % Left margin
    right=25mm,    % Right margin
    top=25mm,      % Top margin
    bottom=30mm,   % Bottom margin
    columnsep=6mm, % Space between columns
    marginparwidth=15mm % Margin notes width
]{{geometry}}

% Two-column layout
\\usepackage{{multicol}}

% Enhanced typography
\\usepackage{{microtype}}  % Better letter spacing and word breaking
\\usepackage{{setspace}}   % Line spacing control

% Paragraph formatting with spacing
\\setlength{{\\parindent}}{{0pt}}
\\setlength{{\\parskip}}{{6pt plus 2pt minus 1pt}}

% Headers and page numbers
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[C]{{\\thepage}}
\\fancyhead[L]{{\\nouppercase{{{title}}}}}
\\fancyhead[R]{{\\nouppercase{{{subtitle}}}}}
\\renewcommand{{\\headrulewidth}}{{0.4pt}}
\\setlength{{\\headheight}}{{14pt}}

% Code highlighting
\\usepackage{{listings}}
\\usepackage{{xcolor}}

\\lstset{{
    basicstyle=\\ttfamily\\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\\color{{gray!10}},
    commentstyle=\\color{{gray}},
    keywordstyle=\\color{{blue}},
    stringstyle=\\color{{red}},
    numbers=left,
    numberstyle=\\tiny\\color{{gray}},
    stepnumber=1,
    tabsize=2
}}

% Links and references
\\usepackage{{hyperref}}
\\hypersetup{{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    citecolor=black,
    pdfborder={{0 0 0}}
}}

% Better chapter formatting
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\huge\\bfseries\\raggedright}}
{{\\chaptertitlename\\ \\thechapter}}{{20pt}}{{\\Huge}}
\\titlespacing*{{\\chapter}}{{0pt}}{{0pt}}{{40pt}}

% Table support
\\usepackage{{booktabs}}
\\usepackage{{longtable}}
\\usepackage{{array}}

% Graphics support
\\usepackage{{graphicx}}

% Better list formatting
\\usepackage{{enumitem}}
\\setlist[itemize]{{leftmargin=*,topsep=3pt,itemsep=1pt}}
\\setlist[enumerate]{{leftmargin=*,topsep=3pt,itemsep=1pt}}

\\begin{{document}}

% Title page
\\begin{{titlepage}}
\\centering
\\vspace*{{2cm}}

{{\\Huge\\bfseries {title}}}

\\vspace{{1cm}}

{{\\Large {subtitle}}}

\\vspace{{2cm}}

{{\\large {author}}}

\\vfill

{{\\large\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

% Start two-column layout for main content
\\begin{{multicols}}{{2}}

'''

    # LaTeX ending
    ending = r'''
\end{multicols}
\end{document}
'''

    # Combine everything
    full_content = preamble
    
    for md_file in sorted(md_files):
        print(f"Processing {md_file}...")
        file_content = convert_markdown_file(md_file, use_sections)
        full_content += file_content + "\n\n"
    
    full_content += ending
    
    # Write to output file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(full_content)
    
    print(f"LaTeX file created: {output_file}")

def compile_pdf(tex_file):
    """Compile the LaTeX file to PDF using XeLaTeX (required for fontspec)"""
    print("Compiling PDF with XeLaTeX...")
    
    # Get the directory and filename
    tex_dir = os.path.dirname(tex_file) or '.'
    tex_name = os.path.basename(tex_file)
    
    # Run XeLaTeX twice for proper cross-references
    for i in range(2):
        result = subprocess.run([
            'xelatex', 
            '-interaction=nonstopmode',
            tex_name
        ], capture_output=True, text=True, cwd=tex_dir)
        
        if result.returncode != 0:
            print(f"XeLaTeX compilation failed on pass {i+1}:")
            print(result.stdout)
            print(result.stderr)
            return False
        else:
            print(f"XeLaTeX pass {i+1} completed successfully")
    
    return True

def main():
    parser = argparse.ArgumentParser(
        description='Convert Markdown files to a professional book-style PDF'
    )
    parser.add_argument(
        'markdown_files',
        nargs='*',
        help='Markdown files to convert (default: all .md files in current directory)'
    )
    parser.add_argument(
        '-o', '--output',
        default='book.tex',
        help='Output LaTeX file name (default: book.tex)'
    )
    parser.add_argument(
        '--no-compile',
        action='store_true',
        help='Generate LaTeX only, do not compile to PDF'
    )
    parser.add_argument(
        '--title',
        default='Your Book Title',
        help='Book title for the title page'
    )
    parser.add_argument(
        '--author',
        default='Author Name',
        help='Author name for the title page'
    )
    parser.add_argument(
        '--subtitle',
        default='Subtitle or Description',
        help='Subtitle for the title page'
    )
    parser.add_argument(
        '--sections',
        action='store_true',
        help='Use sections instead of chapters for # headers (better for shorter documents)'
    )
    
    args = parser.parse_args()
    
    # Find Markdown files
    if args.markdown_files:
        md_files = args.markdown_files
    else:
        md_files = glob.glob('*.md')
    
    if not md_files:
        print("No Markdown files found!")
        sys.exit(1)
    
    print(f"Found {len(md_files)} Markdown files:")
    for f in sorted(md_files):
        print(f"  - {f}")
    
    # Collect metadata from all files
    all_metadata = {}
    for md_file in md_files:
        with open(md_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        metadata, _ = extract_yaml_front_matter(lines)
        all_metadata.update(metadata)
    
    # Use command-line args as defaults, but override with YAML metadata if present
    title = all_metadata.get('title', args.title)
    author = all_metadata.get('author', args.author)
    subtitle = all_metadata.get('subtitle', args.subtitle)
    
    # Create the LaTeX document
    create_latex_document(md_files, args.output, args.sections, title, author, subtitle)
    
    # Optionally compile to PDF
    if not args.no_compile:
        if compile_pdf(args.output):
            pdf_name = args.output.replace('.tex', '.pdf')
            print(f"PDF created successfully: {pdf_name}")
        else:
            print("PDF compilation failed. LaTeX file is still available.")
    
    print("\nTo manually compile the LaTeX file, use:")
    print(f"xelatex {args.output}")
    print("(Run twice for proper cross-references)")

if __name__ == '__main__':
    main()

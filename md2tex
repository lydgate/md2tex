#!/usr/bin/env python3
"""
Markdown to LaTeX Book Converter
Converts 51 Markdown files to a professional book-style PDF using Minion Pro font
Optimized for A4 paper with two-column layout for maximum readability
"""

import os
import re
import sys
import glob
import argparse
from pathlib import Path
import subprocess

def escape_latex(text):
    """Escape special LaTeX characters in text, but preserve LaTeX commands"""
    # Dictionary of LaTeX special characters and their escaped versions
    latex_chars = {
        '&': r'\&',
        '%': r'\%',
        '$': r'\$',
        '#': r'\#',
        '^': r'\textasciicircum{}',
        '_': r'\_',
        '~': r'\textasciitilde{}',
    }
    
    # Escape special characters (but not backslashes, braces, or LaTeX commands)
    for char, escape in latex_chars.items():
        text = text.replace(char, escape)
    
    return text

def process_formatting(text):
    """Process bold, italic, and other formatting in text, then escape LaTeX"""
    # Inline code (must be first to avoid conflicts)
    text = re.sub(r'`([^`]+)`', r'\\texttt{\\detokenize{\1}}', text)
    
    # Bold and italic
    text = re.sub(r'\*\*\*([^*]+)\*\*\*', r'\\textbf{\\textit{\1}}', text)
    text = re.sub(r'\*\*([^*]+)\*\*', r'\\textbf{\1}', text)
    text = re.sub(r'\*([^*]+)\*', r'\\textit{\1}', text)
    text = re.sub(r'___([^_]+)___', r'\\textbf{\\textit{\1}}', text)
    text = re.sub(r'__([^_]+)__', r'\\textbf{\1}', text)
    text = re.sub(r'_([^_]+)_', r'\\textit{\1}', text)
    
    # Links - show text with hyperlink and footnote with URL for print
    def process_link(match):
        link_text = match.group(1)
        url = match.group(2)
        # Show the link text with hyperlink, and add footnote with URL
        return f'\\href{{{url}}}{{{link_text}}}\\footnote{{\\url{{{url}}}}}'
    
    text = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', process_link, text)
    
    # Handle quotes - convert to LaTeX quote conventions
    # Single quotes: 'text' -> `text' (but avoid contractions like don't, won't)
    # Use word boundaries to avoid matching apostrophes in contractions
    text = re.sub(r"(?<!\w)'([^']*)'(?!\w)", r"`\1'", text)
    # Double quotes: "text" -> ``text''
    text = re.sub(r'"([^"]*)"', r"``\1''", text)
    
    # Handle dashes - convert to proper typography
    # Convert Unicode em dash to LaTeX em dash for better compatibility (Chicago style: no spaces)
    text = re.sub(r'\s*—\s*', r'---', text)
    
    # Convert spaced em dashes (manual entry) to unspaced em dashes per Chicago style
    text = re.sub(r'\s*---\s*', r'---', text)
    
    # Convert Unicode en dash to LaTeX en dash for better compatibility  
    text = re.sub(r'–', r'--', text)
    
    # Convert number ranges to en dashes (3-4 becomes 3--4)
    text = re.sub(r'(\d+)\s*-\s*(\d+)', r'\1--\2', text)
    
    # Convert date ranges to en dashes (2020-2023, Jan-Feb, etc.)
    text = re.sub(r'(\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)\b)\s*-\s*(\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)\b)', r'\1--\2', text)
    
    # Convert page ranges and similar constructs (pages 10-15, chapters 1-3)
    text = re.sub(r'(\b(?:pages?|chapters?|sections?|parts?|volumes?|numbers?|lines?|verses?|items?)\s+\d+)\s*-\s*(\d+)', r'\1--\2', text, flags=re.IGNORECASE)
    
    # Escape remaining text
    return escape_latex(text)

def process_markdown_line(line, use_sections=False):
    """Convert a single line of Markdown to LaTeX"""
    line = line.rstrip()
    
    # Skip empty lines (they'll be handled by paragraph spacing)
    if not line.strip():
        return ""
    
    # Headers - process formatting before escaping
    if line.startswith('# '):
        title = line[2:].strip()
        title = process_formatting(title)
        if use_sections:
            return f"\\section{{{title}}}\n"
        else:
            return f"\\chapter{{{title}}}\n"
    elif line.startswith('## '):
        title = line[3:].strip()
        title = process_formatting(title)
        return f"\\subsection{{{title}}}\n"
    elif line.startswith('### '):
        title = line[4:].strip()
        title = process_formatting(title)
        return f"\\subsubsection{{{title}}}\n"
    elif line.startswith('#### '):
        title = line[5:].strip()
        title = process_formatting(title)
        return f"\\paragraph{{{title}}}\n"
    elif line.startswith('##### '):
        title = line[6:].strip()
        title = process_formatting(title)
        return f"\\subparagraph{{{title}}}\n"
    elif line.startswith('###### '):
        title = line[7:].strip()
        title = process_formatting(title)
        return f"\\subparagraph{{{title}}}\n"
    
    # Lists
    elif line.strip().startswith('- ') or line.strip().startswith('* '):
        content = process_formatting(line.strip()[2:])
        return f"\\item {content}"
    elif re.match(r'^\s*\d+\.\s+', line):
        content = process_formatting(re.sub(r'^\s*\d+\.\s+', '', line))
        return f"\\item {content}"
    
    # Code blocks
    elif line.strip().startswith('```'):
        lang = line.strip()[3:].strip()
        if lang:
            return f"\\begin{{lstlisting}}[language={lang}]"
        else:
            return "\\begin{lstlisting}"
    elif line.strip() == '```':
        return "\\end{lstlisting}\n"
    
    # Regular paragraph content - use process_formatting for consistency
    return process_formatting(line) + "\n"

def extract_yaml_front_matter(lines):
    """Extract YAML front matter from the beginning of a markdown file"""
    if not lines or not lines[0].strip().startswith('---'):
        return {}, lines
    
    # Find the end of YAML front matter
    end_index = -1
    for i, line in enumerate(lines[1:], 1):
        if line.strip() == '---':
            end_index = i
            break
    
    if end_index == -1:
        return {}, lines
    
    # Extract YAML content
    yaml_lines = lines[1:end_index]
    yaml_content = {}
    
    for line in yaml_lines:
        line = line.strip()
        if ':' in line:
            key, value = line.split(':', 1)
            key = key.strip()
            value = value.strip().strip('"\'')  # Remove quotes
            yaml_content[key] = value
    
    # Return remaining lines (after the closing ---)
    return yaml_content, lines[end_index + 1:]

def convert_markdown_file(md_file_path, use_sections=False):
    """Convert a single Markdown file to LaTeX content"""
    with open(md_file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    # Extract YAML front matter
    yaml_metadata, content_lines = extract_yaml_front_matter(lines)
    
    latex_content = []
    in_list = False
    in_ordered_list = False
    in_code_block = False
    paragraph_buffer = []
    
    for line in content_lines:
        line = line.rstrip()
        
        # Handle code blocks
        if line.strip().startswith('```'):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if in_code_block:
                latex_content.append("\\end{lstlisting}\n\n")
                in_code_block = False
            else:
                lang = line.strip()[3:].strip()
                if lang:
                    latex_content.append(f"\\begin{{lstlisting}}[language={lang}]\n")
                else:
                    latex_content.append("\\begin{lstlisting}\n")
                in_code_block = True
            continue
        
        if in_code_block:
            latex_content.append(line + "\n")
            continue
        
        # Handle empty lines
        if not line.strip():
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            continue
        
        # Handle headers
        if line.startswith('#'):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if in_list:
                latex_content.append("\\end{itemize}\n\n")
                in_list = False
            if in_ordered_list:
                latex_content.append("\\end{enumerate}\n\n")
                in_ordered_list = False
            
            latex_content.append(process_markdown_line(line, use_sections))
            continue
        
        # Handle lists
        if line.strip().startswith(('- ', '* ')):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if not in_list:
                if in_ordered_list:
                    latex_content.append("\\end{enumerate}\n\n")
                    in_ordered_list = False
                latex_content.append("\\begin{itemize}\n")
                in_list = True
            
            latex_content.append(process_markdown_line(line, use_sections) + "\n")
            continue
        
        elif re.match(r'^\s*\d+\.\s+', line):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if not in_ordered_list:
                if in_list:
                    latex_content.append("\\end{itemize}\n\n")
                    in_list = False
                latex_content.append("\\begin{enumerate}\n")
                in_ordered_list = True
            
            latex_content.append(process_markdown_line(line, use_sections) + "\n")
            continue
        
        # Close lists if we're not in a list item
        if in_list:
            latex_content.append("\\end{itemize}\n\n")
            in_list = False
        if in_ordered_list:
            latex_content.append("\\end{enumerate}\n\n")
            in_ordered_list = False
        
        # Regular paragraph content
        processed_line = process_markdown_line(line, use_sections).strip()
        if processed_line:
            paragraph_buffer.append(processed_line)
    
    # Handle remaining content
    if paragraph_buffer:
        latex_content.append(' '.join(paragraph_buffer) + "\n\n")
    
    if in_list:
        latex_content.append("\\end{itemize}\n\n")
    if in_ordered_list:
        latex_content.append("\\end{enumerate}\n\n")
    
    return ''.join(latex_content)

def create_latex_document(md_files, output_file, use_sections=False, title="Your Book Title", author="Author Name", subtitle="Subtitle or Description", novel=False, royal=False, kdp=False):
    """Create the complete LaTeX document"""
    
    if kdp:
        # KDP 6x9 inch format (152.4 x 228.6mm) optimized for Amazon KDP
        preamble = f'''\\documentclass[12pt,twoside]{{book}}

% Font setup - Minion Pro
\\usepackage{{fontspec}}
\\setmainfont{{Minion Pro}}
\\setsansfont{{Myriad Pro}}
\\setmonofont{{Consolas Ligaturized}}

% Page layout for KDP 6x9 inch format (152.4 x 228.6mm)
\\usepackage[
    paperwidth=152.4mm,
    paperheight=228.6mm,
    inner=15.9mm,    % 0.625in inner margin for spine (suitable for 301-500 pages)
    outer=12.7mm,    % 0.5in outer margin (well above 0.25in minimum)
    top=19.1mm,      % 0.75in top margin (well above 0.25in minimum)
    bottom=19.1mm    % 0.75in bottom margin (well above 0.25in minimum)
]{{geometry}}

% Enhanced typography
\\usepackage{{microtype}}  % Better letter spacing and word breaking
\\usepackage{{setspace}}   % Line spacing control

% Paragraph formatting optimized for readability and margin compliance
\\setlength{{\\parindent}}{{12pt}}
\\setlength{{\\parskip}}{{0pt plus 1pt}}
\\setlength{{\\emergencystretch}}{{3em}}  % Allow more flexibility in line breaking
\\setlength{{\\tolerance}}{{9999}}        % Be more tolerant of spacing to avoid overfull lines

% Headers and page numbers for KDP two-sided format
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[LE,RO]{{\\thepage}}
\\fancyhead[LO]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[RE]{{\\nouppercase{{{subtitle}}}}}
\\renewcommand{{\\headrulewidth}}{{0pt}}
\\setlength{{\\headheight}}{{14pt}}

% Code highlighting
\\usepackage{{listings}}
\\usepackage{{xcolor}}

\\lstset{{
    basicstyle=\\ttfamily\\small,
    breaklines=true,
    breakatwhitespace=true,
    frame=single,
    backgroundcolor=\\color{{gray!10}},
    commentstyle=\\color{{gray}},
    keywordstyle=\\color{{blue}},
    stringstyle=\\color{{red}},
    numbers=left,
    numberstyle=\\tiny\\color{{gray}},
    stepnumber=1,
    tabsize=2,
    xleftmargin=5pt,
    xrightmargin=5pt,
    breakindent=0pt,
    prebreak=\\mbox{{\\textbackslash}}
}}

% Links and references
\\usepackage{{hyperref}}
\\usepackage{{url}}  % Better URL formatting and breaking
\\hypersetup{{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    citecolor=black,
    pdfborder={{0 0 0}},
    breaklinks=true  % Allow URLs to break across lines
}}

% Configure URL line breaking
\\urlstyle{{same}}  % Use same font as text
\\def\\UrlBreaks{{\\do\\/\\do\\-\\do\\.\\do\\:\\do\\?\\do\\=\\do\\&}}  % Allow breaks at these characters

% Chapter formatting optimized for KDP
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\Large\\bfseries\\centering}}
{{}}{{0pt}}{{\\Large}}
\\titlespacing*{{\\chapter}}{{0pt}}{{30pt}}{{20pt}}

% Table support
\\usepackage{{booktabs}}
\\usepackage{{longtable}}
\\usepackage{{array}}

% Graphics support
\\usepackage{{graphicx}}

% Better list formatting
\\usepackage{{enumitem}}
\\setlist[itemize]{{leftmargin=*,topsep=3pt,itemsep=1pt}}
\\setlist[enumerate]{{leftmargin=*,topsep=3pt,itemsep=1pt}}

\\begin{{document}}

% Title page (KDP compliant)
\\begin{{titlepage}}
\\centering
\\vspace*{{3cm}}

{{\\Large\\bfseries {title}}}

\\vspace{{1cm}}

{{\\normalsize {subtitle}}}

\\vspace{{2cm}}

{{\\normalsize {author}}}

\\vfill

{{\\small\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

'''
        
        # KDP ending (no multicols)
        ending = r'''
\end{document}
'''
    elif novel:
        # Single-column novel format (203x127mm, two-sided)
        preamble = f'''\\documentclass[11pt,twoside]{{book}}

% Font setup - Minion Pro
\\usepackage{{fontspec}}
\\setmainfont{{Minion Pro}}
\\setsansfont{{Myriad Pro}}
\\setmonofont{{Consolas Ligaturized}}

% Page layout for 203x127mm (8x5in) novel format
\\usepackage[
    paperwidth=127mm,
    paperheight=203mm,
    inner=22mm,      % Inner margin (binding side)
    outer=15mm,      % Outer margin
    top=20mm,        % Top margin
    bottom=20mm      % Bottom margin
]{{geometry}}

% Enhanced typography
\\usepackage{{microtype}}  % Better letter spacing and word breaking
\\usepackage{{setspace}}   % Line spacing control

% Paragraph formatting with spacing
\\setlength{{\\parindent}}{{12pt}}
\\setlength{{\\parskip}}{{0pt plus 1pt}}

% Headers and page numbers for two-sided novel
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[LE,RO]{{\\thepage}}
\\fancyhead[LO]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[RE]{{\\nouppercase{{{subtitle}}}}}
\\renewcommand{{\\headrulewidth}}{{0pt}}
\\setlength{{\\headheight}}{{14pt}}

% Code highlighting
\\usepackage{{listings}}
\\usepackage{{xcolor}}

\\lstset{{
    basicstyle=\\ttfamily\\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\\color{{gray!10}},
    commentstyle=\\color{{gray}},
    keywordstyle=\\color{{blue}},
    stringstyle=\\color{{red}},
    numbers=left,
    numberstyle=\\tiny\\color{{gray}},
    stepnumber=1,
    tabsize=2
}}

% Links and references
\\usepackage{{hyperref}}
\\hypersetup{{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    citecolor=black,
    pdfborder={{0 0 0}}
}}

% Better chapter formatting for novel
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\Large\\bfseries\\centering}}
{{}}{{0pt}}{{\\Large}}
\\titlespacing*{{\\chapter}}{{0pt}}{{30pt}}{{20pt}}

% Table support
\\usepackage{{booktabs}}
\\usepackage{{longtable}}
\\usepackage{{array}}

% Graphics support
\\usepackage{{graphicx}}

% Better list formatting
\\usepackage{{enumitem}}
\\setlist[itemize]{{leftmargin=*,topsep=3pt,itemsep=1pt}}
\\setlist[enumerate]{{leftmargin=*,topsep=3pt,itemsep=1pt}}

\\begin{{document}}

% Title page
\\begin{{titlepage}}
\\centering
\\vspace*{{3cm}}

{{\\Large\\bfseries {title}}}

\\vspace{{1cm}}

{{\\normalsize {subtitle}}}

\\vspace{{2cm}}

{{\\normalsize {author}}}

\\vfill

{{\\small\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

'''
        
        # Novel ending (no multicols)
        ending = r'''
\end{document}
'''
        
    elif royal:
        # Single-column royal format (234x156mm, two-sided)
        preamble = f'''\\documentclass[11pt,twoside]{{book}}

% Font setup - Minion Pro
\\usepackage{{fontspec}}
\\setmainfont{{Minion Pro}}
\\setsansfont{{Myriad Pro}}
\\setmonofont{{Consolas Ligaturized}}

% Page layout for 234x156mm Royal format
\\usepackage[
    paperwidth=156mm,
    paperheight=234mm,
    inner=25mm,      % Inner margin (binding side)
    outer=18mm,      % Outer margin
    top=22mm,        % Top margin
    bottom=22mm      % Bottom margin
]{{geometry}}

% Enhanced typography
\\usepackage{{microtype}}  % Better letter spacing and word breaking
\\usepackage{{setspace}}   % Line spacing control

% Paragraph formatting with spacing
\\setlength{{\\parindent}}{{12pt}}
\\setlength{{\\parskip}}{{0pt plus 1pt}}

% Headers and page numbers for two-sided royal
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[LE,RO]{{\\thepage}}
\\fancyhead[LO]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[RE]{{\\nouppercase{{{subtitle}}}}}
\\renewcommand{{\\headrulewidth}}{{0pt}}
\\setlength{{\\headheight}}{{14pt}}

% Code highlighting
\\usepackage{{listings}}
\\usepackage{{xcolor}}

\\lstset{{
    basicstyle=\\ttfamily\\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\\color{{gray!10}},
    commentstyle=\\color{{gray}},
    keywordstyle=\\color{{blue}},
    stringstyle=\\color{{red}},
    numbers=left,
    numberstyle=\\tiny\\color{{gray}},
    stepnumber=1,
    tabsize=2
}}

% Links and references
\\usepackage{{hyperref}}
\\hypersetup{{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    citecolor=black,
    pdfborder={{0 0 0}}
}}

% Better chapter formatting for royal
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\Large\\bfseries\\centering}}
{{}}{{0pt}}{{\\Large}}
\\titlespacing*{{\\chapter}}{{0pt}}{{30pt}}{{20pt}}

% Table support
\\usepackage{{booktabs}}
\\usepackage{{longtable}}
\\usepackage{{array}}

% Graphics support
\\usepackage{{graphicx}}

% Better list formatting
\\usepackage{{enumitem}}
\\setlist[itemize]{{leftmargin=*,topsep=3pt,itemsep=1pt}}
\\setlist[enumerate]{{leftmargin=*,topsep=3pt,itemsep=1pt}}

\\begin{{document}}

% Title page
\\begin{{titlepage}}
\\centering
\\vspace*{{3cm}}

{{\\Large\\bfseries {title}}}

\\vspace{{1cm}}

{{\\normalsize {subtitle}}}

\\vspace{{2cm}}

{{\\normalsize {author}}}

\\vfill

{{\\small\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

'''
        
        # Royal ending (no multicols)
        ending = r'''
\end{document}
'''
        
    else:
        # Original A4 two-column format
        preamble = f'''\\documentclass[11pt,a4paper,oneside]{{book}}

% Font setup - Minion Pro
\\usepackage{{fontspec}}
\\setmainfont{{Minion Pro}}
\\setsansfont{{Myriad Pro}}
\\setmonofont{{Consolas Ligaturized}}

% Page layout optimized for A4 single-sided printing with balanced margins
\\usepackage[
    a4paper,
    left=25mm,     % Left margin
    right=25mm,    % Right margin
    top=25mm,      % Top margin
    bottom=25mm,   % Bottom margin (now equal to top)
    columnsep=12.5mm, % Space between columns (increased for better balance)
    marginparwidth=15mm % Margin notes width
]{{geometry}}

% Two-column layout
\\usepackage{{multicol}}

% Enhanced typography
\\usepackage{{microtype}}  % Better letter spacing and word breaking
\\usepackage{{setspace}}   % Line spacing control

% Paragraph formatting with spacing
\\setlength{{\\parindent}}{{0pt}}
\\setlength{{\\parskip}}{{6pt plus 2pt minus 1pt}}

% Headers and page numbers
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[C]{{\\thepage}}
\\fancyhead[L]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[R]{{\\nouppercase{{{subtitle}}}}}
\\renewcommand{{\\headrulewidth}}{{0.4pt}}
\\setlength{{\\headheight}}{{14pt}}

% Code highlighting
\\usepackage{{listings}}
\\usepackage{{xcolor}}

\\lstset{{
    basicstyle=\\ttfamily\\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\\color{{gray!10}},
    commentstyle=\\color{{gray}},
    keywordstyle=\\color{{blue}},
    stringstyle=\\color{{red}},
    numbers=left,
    numberstyle=\\tiny\\color{{gray}},
    stepnumber=1,
    tabsize=2
}}

% Links and references
\\usepackage{{hyperref}}
\\hypersetup{{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    citecolor=black,
    pdfborder={{0 0 0}}
}}

% Better chapter formatting
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\huge\\bfseries\\raggedright}}
{{\\chaptertitlename\\ \\thechapter}}{{20pt}}{{\\Huge}}
\\titlespacing*{{\\chapter}}{{0pt}}{{0pt}}{{40pt}}

% Table support
\\usepackage{{booktabs}}
\\usepackage{{longtable}}
\\usepackage{{array}}

% Graphics support
\\usepackage{{graphicx}}

% Better list formatting
\\usepackage{{enumitem}}
\\setlist[itemize]{{leftmargin=*,topsep=3pt,itemsep=1pt}}
\\setlist[enumerate]{{leftmargin=*,topsep=3pt,itemsep=1pt}}

\\begin{{document}}

% Title page
\\begin{{titlepage}}
\\centering
\\vspace*{{2cm}}

{{\\Huge\\bfseries {title}}}

\\vspace{{1cm}}

{{\\Large {subtitle}}}

\\vspace{{2cm}}

{{\\large {author}}}

\\vfill

{{\\large\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

% Start two-column layout for main content
\\begin{{multicols}}{{2}}

'''

        # A4 two-column ending
        ending = r'''
\end{multicols}
\end{document}
'''

    # Combine everything
    full_content = preamble
    
    for md_file in sorted(md_files):
        print(f"Processing {md_file}...")
        file_content = convert_markdown_file(md_file, use_sections)
        full_content += file_content + "\n\n"
    
    full_content += ending
    
    # Write to output file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(full_content)
    
    print(f"LaTeX file created: {output_file}")

def compile_pdf(tex_file):
    """Compile the LaTeX file to PDF using XeLaTeX (required for fontspec)"""
    print("Compiling PDF with XeLaTeX...")
    
    # Get the directory and filename
    tex_dir = os.path.dirname(tex_file) or '.'
    tex_name = os.path.basename(tex_file)
    
    # Run XeLaTeX twice for proper cross-references
    for i in range(2):
        result = subprocess.run([
            'xelatex', 
            '-interaction=nonstopmode',
            tex_name
        ], capture_output=True, text=True, cwd=tex_dir)
        
        if result.returncode != 0:
            print(f"XeLaTeX compilation failed on pass {i+1}:")
            print(result.stdout)
            print(result.stderr)
            return False
        else:
            print(f"XeLaTeX pass {i+1} completed successfully")
    
    return True

def cleanup_latex_files(tex_file, verbose=False):
    """Remove intermediate LaTeX files, keeping only the PDF"""
    base_name = tex_file.replace('.tex', '')
    
    # List of file extensions to remove
    extensions_to_remove = ['.tex', '.aux', '.log', '.out', '.toc']
    removed_files = []
    
    for ext in extensions_to_remove:
        file_to_remove = base_name + ext
        if os.path.exists(file_to_remove):
            try:
                os.remove(file_to_remove)
                removed_files.append(file_to_remove)
                if verbose:
                    print(f"Removed: {file_to_remove}")
            except OSError as e:
                if verbose:
                    print(f"Could not remove {file_to_remove}: {e}")
    
    if verbose and removed_files:
        print(f"Cleanup complete. Removed {len(removed_files)} intermediate files.")
    elif verbose:
        print("No intermediate files to remove.")
    
    return removed_files

def main():
    parser = argparse.ArgumentParser(
        description='Convert Markdown files to a professional book-style PDF'
    )
    parser.add_argument(
        'markdown_files',
        nargs='*',
        help='Markdown files to convert (default: all .md files in current directory)'
    )
    parser.add_argument(
        '-o', '--output',
        default='book.tex',
        help='Output LaTeX file name (default: book.tex, or input filename for single files)'
    )
    parser.add_argument(
        '--no-compile',
        action='store_true',
        help='Generate LaTeX only, do not compile to PDF'
    )
    parser.add_argument(
        '--title',
        default='Your Book Title',
        help='Book title for the title page'
    )
    parser.add_argument(
        '--author',
        default='Author Name',
        help='Author name for the title page'
    )
    parser.add_argument(
        '--subtitle',
        default='Subtitle or Description',
        help='Subtitle for the title page'
    )
    parser.add_argument(
        '--sections',
        action='store_true',
        help='Use sections instead of chapters for # headers (better for shorter documents)'
    )
    parser.add_argument(
        '--novel',
        action='store_true',
        help='Create a single-column, two-sided, 203x127mm format novel'
    )
    parser.add_argument(
        '--royal',
        action='store_true',
        help='Create a single-column, two-sided, 234x156mm format royal'
    )
    parser.add_argument(
        '--kdp',
        action='store_true',
        help='Create a single-column, 6x9 inch (152.4 x 228.6mm) format optimized for Amazon KDP'
    )
    parser.add_argument(
        '-c', '--cleanup',
        action='store_true',
        help='Remove intermediate LaTeX files (.aux, .log, .out, .tex, .toc) after compilation'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Verbose output - list files being processed and removed'
    )
    
    args = parser.parse_args()
    
    # Find Markdown files
    if args.markdown_files:
        md_files = args.markdown_files
    else:
        md_files = glob.glob('*.md')
    
    if not md_files:
        print("No Markdown files found!")
        sys.exit(1)
    
    # Set default output filename based on input if not explicitly provided
    if args.output == 'book.tex' and len(md_files) == 1:
        # Extract base name from single input file
        input_path = Path(md_files[0])
        base_name = input_path.stem  # filename without extension
        args.output = f"{base_name}.tex"
    
    print(f"Found {len(md_files)} Markdown files:")
    for f in sorted(md_files):
        print(f"  - {f}")
    
    # Collect metadata from all files
    all_metadata = {}
    for md_file in md_files:
        with open(md_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        metadata, _ = extract_yaml_front_matter(lines)
        all_metadata.update(metadata)
    
    # Use command-line args as defaults, but override with YAML metadata if present
    title = all_metadata.get('title', args.title)
    author = all_metadata.get('author', args.author)
    subtitle = all_metadata.get('subtitle', args.subtitle)
    
    # Create the LaTeX document
    # Use sections for novel, royal, and KDP formats by default
    use_sections = args.sections or args.novel or args.royal or args.kdp
    create_latex_document(md_files, args.output, use_sections, title, author, subtitle, args.novel, args.royal, args.kdp)
    
    # Optionally compile to PDF
    pdf_created = False
    if not args.no_compile:
        if compile_pdf(args.output):
            pdf_name = args.output.replace('.tex', '.pdf')
            print(f"PDF created successfully: {pdf_name}")
            pdf_created = True
        else:
            print("PDF compilation failed. LaTeX file is still available.")
    
    # Cleanup intermediate files if requested or by default when PDF was created
    if args.cleanup or (pdf_created and not args.no_compile):
        if args.verbose:
            print("\nCleaning up intermediate files...")
        cleanup_latex_files(args.output, args.verbose)
    
    if not pdf_created:
        print("\nTo manually compile the LaTeX file, use:")
        print(f"xelatex {args.output}")
        print("(Run twice for proper cross-references)")

if __name__ == '__main__':
    main()

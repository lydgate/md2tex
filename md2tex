#!/usr/bin/env python3
"""
Markdown to LaTeX Book Converter
Converts 51 Markdown files to a professional book-style PDF using Minion Pro font
Optimized for A4 paper with two-column layout for maximum readability
"""

import os
import re
import sys
import glob
import argparse
from pathlib import Path
import subprocess

# =============================================================================
# COMMON TEMPLATE PARTS - Extract the truly identical sections
# =============================================================================

FONT_SETUP = r"""% Font setup - Minion Pro
\usepackage{fontspec}
\setmainfont{Minion Pro}
\setsansfont{Myriad Pro}
\setmonofont{Consolas Ligaturized}"""

def get_typography_packages(debug_overfull=False):
    """Get typography packages with conditional overfull box handling"""
    overfull_rule = "0pt" if not debug_overfull else "1pt"
    return f"""% Enhanced typography
\\usepackage{{microtype}}  % Better letter spacing and word breaking
\\usepackage{{setspace}}   % Line spacing control
\\usepackage{{hyphenat}}   % Better hyphenation control

% Better line breaking and overfull hbox handling
\\setlength{{\\emergencystretch}}{{3em}}  % Allow more flexibility in line breaking
\\setlength{{\\tolerance}}{{9999}}        % Be more tolerant of spacing to avoid overfull lines
\\setlength{{\\overfullrule}}{{{overfull_rule}}}      % {'Show' if debug_overfull else 'Hide'} overfull boxes
\\setlength{{\\hfuzz}}{{0.5pt}}           % Allow small overfull lines
\\raggedbottom                        % Don't stretch content to fill pages

% Hyphenation settings for better line breaking
\\hyphenpenalty=50                    % Penalty for hyphenation
\\exhyphenpenalty=50                  % Penalty for hyphenation after explicit hyphen
\\doublehyphendemerits=10000          % Penalty for consecutive hyphenated lines
\\finalhyphendemerits=5000            % Penalty for hyphenating the second-to-last line"""

CODE_HIGHLIGHTING_BASE = r"""% Code highlighting
\usepackage{listings}
\usepackage{xcolor}

\lstset{
    basicstyle=\ttfamily\small,
    breaklines=true,
    frame=single,
    backgroundcolor=\color{gray!10},
    commentstyle=\color{gray},
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    tabsize=2"""

# KDP has additional settings
CODE_HIGHLIGHTING_KDP = CODE_HIGHLIGHTING_BASE + r""",
    breakatwhitespace=true,
    xleftmargin=5pt,
    xrightmargin=5pt,
    breakindent=0pt,
    prebreak=\mbox{\textbackslash}
}"""

CODE_HIGHLIGHTING_STANDARD = CODE_HIGHLIGHTING_BASE + r"""
}"""

LINKS_REFERENCES_BASE = r"""% Links and references
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    urlcolor=blue,
    citecolor=black,
    pdfborder={0 0 0}"""

FOOTNOTE_SUPPORT = r"""% Footnote support for markdown-style footnotes
\usepackage{footnote}
\makeatletter
\newcommand{\footnoteid}[1]{#1}
\makeatother"""

# KDP has additional URL breaking features
LINKS_REFERENCES_KDP = LINKS_REFERENCES_BASE + r""",
    breaklinks=true  % Allow URLs to break across lines
}

\usepackage{url}  % Better URL formatting and breaking

% Configure URL line breaking
\urlstyle{same}  % Use same font as text
\def\UrlBreaks{\do\/\do\-\do\.\do\:\do\?\do\=\do\&}  % Allow breaks at these characters"""

LINKS_REFERENCES_STANDARD = LINKS_REFERENCES_BASE + r"""
}"""

TABLE_AND_GRAPHICS = r"""% Table support
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}

% Graphics support
\usepackage{graphicx}"""

LIST_FORMATTING = r"""% Better list formatting
\usepackage{enumitem}
\setlist[itemize]{leftmargin=*,topsep=3pt,itemsep=1pt}
\setlist[enumerate]{leftmargin=*,topsep=3pt,itemsep=1pt}

% Todolist support
\usepackage{amssymb}
\usepackage{graphicx}
\newlist{todolist}{itemize}{1}
\setlist[todolist]{label=\scalebox{1.5}{☐}, leftmargin=*, topsep=3pt, itemsep=1pt}
\newcommand{\checkeditem}{\item[\scalebox{1.5}{☑}]}
\newcommand{\uncheckeditem}{\item[\scalebox{1.5}{☐}]}"""

SECTION_NUMBERING = r"""% Custom section numbering for section mode
\renewcommand{\thesection}{\arabic{section}}
\renewcommand{\thesubsection}{\thesection.\arabic{subsection}}
\renewcommand{\thesubsubsection}{\thesubsection.\arabic{subsubsection}}"""

def get_git_version_info(file_path=None):
    """Get git version information for the current repository"""
    try:
        # Get the directory of the file or current directory
        if file_path:
            repo_dir = os.path.dirname(os.path.abspath(file_path))
        else:
            repo_dir = os.getcwd()
        
        # Check if git command exists
        try:
            subprocess.run(['git', '--version'], capture_output=True, check=True)
        except (subprocess.CalledProcessError, FileNotFoundError):
            print("Warning: git command not found, skipping version information")
            return None, None, None
        
        # Check if we're in a git repository by trying git commands
        try:
            # Try to get git root directory - this will fail if not in a git repo
            subprocess.run(['git', 'rev-parse', '--git-dir'], cwd=repo_dir, capture_output=True, check=True)
        except subprocess.CalledProcessError:
            return None, None, None
        
        # Get the latest tag
        try:
            tag_result = subprocess.run(
                ['git', 'describe', '--tags', '--abbrev=0'],
                cwd=repo_dir,
                capture_output=True,
                text=True,
                check=True
            )
            latest_tag = tag_result.stdout.strip()
        except subprocess.CalledProcessError:
            latest_tag = None
        
        # Get the current commit hash (short)
        try:
            commit_result = subprocess.run(
                ['git', 'rev-parse', '--short', 'HEAD'],
                cwd=repo_dir,
                capture_output=True,
                text=True,
                check=True
            )
            commit_hash = commit_result.stdout.strip()
        except subprocess.CalledProcessError:
            commit_hash = None
        
        # Get the commit date
        try:
            date_result = subprocess.run(
                ['git', 'log', '-1', '--format=%cd', '--date=short'],
                cwd=repo_dir,
                capture_output=True,
                text=True,
                check=True
            )
            commit_date = date_result.stdout.strip()
        except subprocess.CalledProcessError:
            commit_date = None
        
        return latest_tag, commit_hash, commit_date
        
    except Exception as e:
        print(f"Warning: Error getting git version info: {e}")
        return None, None, None

def is_markdown_file(file_path):
    """Check if a file is actually a markdown file by examining its content"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            # Read first few lines to check for markdown patterns
            lines = [f.readline().strip() for _ in range(10)]
            content = '\n'.join(lines)
        
        # Check for LaTeX indicators (if present, it's probably not markdown)
        latex_indicators = [
            r'\\documentclass',
            r'\\usepackage',
            r'\\begin\{',
            r'\\end\{',
            r'\\section\{',
            r'\\chapter\{',
            r'\\href\{',
            r'\\footnote\{'
        ]
        
        for pattern in latex_indicators:
            if re.search(pattern, content):
                return False
        
        # Check for markdown indicators
        markdown_indicators = [
            r'^#\s+',  # Headers
            r'^\*\s+',  # Lists
            r'^\d+\.\s+',  # Numbered lists
            r'\[.*\]\(.*\)',  # Links
            r'```',  # Code blocks
            r'^\>\s+',  # Blockquotes
            r'\[\^.*\]:',  # Footnote definitions
            r'\[\^.*\]',  # Footnote references
        ]
        
        for pattern in markdown_indicators:
            if re.search(pattern, content, re.MULTILINE):
                return True
        
        # If no clear indicators, check file extension
        return file_path.lower().endswith('.md')
        
    except (UnicodeDecodeError, IOError):
        # If we can't read the file, assume it's not markdown
        return False

def escape_latex(text):
    """Escape special LaTeX characters in text, but preserve LaTeX commands"""
    # Dictionary of LaTeX special characters and their escaped versions
    latex_chars = {
        '&': r'\&',
        '%': r'\%',
        '$': r'\$',
        '#': r'\#',
        '^': r'\textasciicircum{}',
        '_': r'\_',
        '~': r'\textasciitilde{}',
    }
    
    # Escape special characters (but not backslashes, braces, or LaTeX commands)
    for char, escape in latex_chars.items():
        text = text.replace(char, escape)
    
    return text

def strip_html_comments(text, keep_comments=False):
    """Remove HTML comments from text, optionally converting to LaTeX comments"""
    if keep_comments:
        # Convert HTML comments to LaTeX comments
        def html_to_latex_comment(match):
            comment_content = match.group(0)
            # Remove the HTML comment markers
            comment_content = comment_content[4:-3]  # Remove <!-- and -->
            # Split into lines and add % to each line
            lines = comment_content.split('\n')
            latex_lines = []
            for line in lines:
                if line.strip():  # Only add % to non-empty lines
                    latex_lines.append(f'% {line.strip()}')
                else:
                    latex_lines.append('%')
            return '\n'.join(latex_lines)
        
        return re.sub(r'<!--.*?-->', html_to_latex_comment, text, flags=re.DOTALL)
    else:
        # Remove HTML comments completely - handle both single line and multiline
        # First remove multiline comments
        text = re.sub(r'<!--.*?-->', '', text, flags=re.DOTALL)
        # Then remove any remaining single-line comments
        text = re.sub(r'<!--[^>]*-->', '', text)
        return text

def process_formatting(text, keep_comments=False, url_footnotes=False):
    """Process bold, italic, and other formatting in text, then escape LaTeX"""
    # First, strip HTML comments
    text = strip_html_comments(text, keep_comments)
    
    # Then, extract and protect all URLs from formatting processing
    url_placeholders = []
    
    def protect_url(match):
        nonlocal url_placeholders
        link_text = match.group(1)
        url = match.group(2)
        placeholder_id = f"URLPLACEHOLDER{len(url_placeholders)}"
        url_placeholders.append((placeholder_id, link_text, url))
        return placeholder_id
    
    # Replace all URLs with placeholders
    text = re.sub(r'\[([^\]]+)\]\(([^)]+)\)', protect_url, text)
    
    # Extract and protect footnote references from formatting processing
    footnote_placeholders = []
    
    def protect_footnote_ref(match):
        nonlocal footnote_placeholders
        footnote_id = match.group(1)
        placeholder_id = f"FOOTNOTEREFPLACEHOLDER{len(footnote_placeholders)}"
        footnote_placeholders.append((placeholder_id, footnote_id))
        return placeholder_id
    
    # Replace footnote references with placeholders
    text = re.sub(r'\[\^([^\]]+)\]', protect_footnote_ref, text)
    
    # Inline code (must be early to avoid conflicts)
    text = re.sub(r'`([^`]+)`', r'\\texttt{\\detokenize{\1}}', text)
    
    # Bold and italic (now applied to remaining text, links already processed)
    text = re.sub(r'\*\*\*([^*]+)\*\*\*', r'\\textbf{\\textit{\1}}', text)
    text = re.sub(r'\*\*([^*]+)\*\*', r'\\textbf{\1}', text)
    text = re.sub(r'\*([^*]+)\*', r'\\textit{\1}', text)
    text = re.sub(r'___([^_]+)___', r'\\textbf{\\textit{\1}}', text)
    text = re.sub(r'__([^_]+)__', r'\\textbf{\1}', text)
    text = re.sub(r'_([^_]+)_', r'\\textit{\1}', text)
    
    # Handle quotes - convert to LaTeX quote conventions
    # Single quotes: 'text' -> `text' (but avoid contractions like don't, won't)
    # Use word boundaries to avoid matching apostrophes in contractions
    text = re.sub(r"(?<!\w)'([^']*)'(?!\w)", r"`\1'", text)
    # Double quotes: "text" -> ``text''
    text = re.sub(r'"([^"]*)"', r"``\1''", text)
    
    # Handle dashes - convert to proper typography
    # Convert Unicode em dash to LaTeX em dash for better compatibility (Chicago style: no spaces)
    text = re.sub(r'\s*—\s*', r'---', text)
    
    # Convert spaced em dashes (manual entry) to unspaced em dashes per Chicago style
    text = re.sub(r'\s*---\s*', r'---', text)
    
    # Convert Unicode en dash to LaTeX en dash for better compatibility  
    text = re.sub(r'–', r'--', text)
    
    # Convert number ranges to en dashes (3-4 becomes 3--4)
    text = re.sub(r'(\d+)\s*-\s*(\d+)', r'\1--\2', text)
    
    # Convert date ranges to en dashes (2020-2023, Jan-Feb, etc.)
    text = re.sub(r'(\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)\b)\s*-\s*(\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)\b)', r'\1--\2', text)
    
    # Convert page ranges and similar constructs (pages 10-15, chapters 1-3)
    text = re.sub(r'(\b(?:pages?|chapters?|sections?|parts?|volumes?|numbers?|lines?|verses?|items?)\s+\d+)\s*-\s*(\d+)', r'\1--\2', text, flags=re.IGNORECASE)
    
    # Restore protected URLs after all formatting is done
    for placeholder_id, link_text, url in url_placeholders:
        # Process the link text for formatting (recursively, but without URLs)
        formatted_link_text = link_text
        formatted_link_text = re.sub(r'\*\*\*([^*]+)\*\*\*', r'\\textbf{\\textit{\1}}', formatted_link_text)
        formatted_link_text = re.sub(r'\*\*([^*]+)\*\*', r'\\textbf{\1}', formatted_link_text)
        formatted_link_text = re.sub(r'\*([^*]+)\*', r'\\textit{\1}', formatted_link_text)
        formatted_link_text = re.sub(r'___([^_]+)___', r'\\textbf{\\textit{\1}}', formatted_link_text)
        formatted_link_text = re.sub(r'__([^_]+)__', r'\\textbf{\1}', formatted_link_text)
        formatted_link_text = re.sub(r'_([^_]+)_', r'\\textit{\1}', formatted_link_text)
        # Create the final LaTeX link
        if url_footnotes:
            # Link with automatic footnote (old behavior - useful for print documents)
            latex_link = f'\\href{{{url}}}{{{formatted_link_text}}}\\footnote{{\\url{{{url}}}}}'
        else:
            # Just the link (current behavior)
            latex_link = f'\\href{{{url}}}{{{formatted_link_text}}}'
        text = text.replace(placeholder_id, latex_link)
    
    # Restore protected footnote references after all formatting is done
    for placeholder_id, footnote_id in footnote_placeholders:
        # Create LaTeX footnote reference using standard LaTeX footnotes
        # We'll use a placeholder that will be replaced with the actual footnote content later
        latex_footnote_ref = f'\\footnote{{\\footnotecontent{{{footnote_id}}}}}'
        text = text.replace(placeholder_id, latex_footnote_ref)
    
    # Escape remaining text
    return escape_latex(text)

def process_markdown_line(line, use_sections=False, keep_comments=False, url_footnotes=False):
    """Convert a single line of Markdown to LaTeX"""
    line = line.rstrip()
    
    # Skip empty lines (they'll be handled by paragraph spacing)
    if not line.strip():
        return ""
    
    # Headers - process formatting before escaping
    if line.startswith('# '):
        title = line[2:].strip()
        title = process_formatting(title, keep_comments, url_footnotes)
        if use_sections:
            return f"\\section{{{title}}}\n"
        else:
            return f"\\chapter{{{title}}}\n"
    elif line.startswith('## '):
        title = line[3:].strip()
        title = process_formatting(title, keep_comments, url_footnotes)
        if use_sections:
            return f"\\subsection{{{title}}}\n"
        else:
            return f"\\section{{{title}}}\n"
    elif line.startswith('### '):
        title = line[4:].strip()
        title = process_formatting(title, keep_comments, url_footnotes)
        if use_sections:
            return f"\\subsubsection{{{title}}}\n"
        else:
            return f"\\subsection{{{title}}}\n"
    elif line.startswith('#### '):
        title = line[5:].strip()
        title = process_formatting(title, keep_comments, url_footnotes)
        if use_sections:
            return f"\\paragraph{{{title}}}\n"
        else:
            return f"\\subsubsection{{{title}}}\n"
    elif line.startswith('##### '):
        title = line[6:].strip()
        title = process_formatting(title, keep_comments, url_footnotes)
        if use_sections:
            return f"\\subparagraph{{{title}}}\n"
        else:
            return f"\\paragraph{{{title}}}\n"
    elif line.startswith('###### '):
        title = line[7:].strip()
        title = process_formatting(title, keep_comments, url_footnotes)
        return f"\\subparagraph{{{title}}}\n"
    
    # Blockquotes
    elif line.strip().startswith('>'):
        # Handle both "> content" and ">" (empty blockquote)
        if line.strip() == '>':
            # Empty blockquote - just add a line break
            return "\n"
        else:
            # Blockquote with content
            content = process_formatting(line.strip()[2:], keep_comments, url_footnotes)
            return f"\\begin{{quote}}\n{content}\n\\end{{quote}}\n"
    
    # Todolist items
    elif re.match(r'^\s*- \[([ x])\]\s+', line):
        # Extract checkbox state and content
        match = re.match(r'^\s*- \[([ x])\]\s+(.*)', line)
        checked = match.group(1) == 'x'
        content = process_formatting(match.group(2), keep_comments, url_footnotes)
        if checked:
            return f"\\checkeditem {content}"
        else:
            return f"\\uncheckeditem {content}"
    
    # Lists
    elif line.strip().startswith('- ') or line.strip().startswith('* '):
        content = process_formatting(line.strip()[2:], keep_comments, url_footnotes)
        return f"\\item {content}"
    elif re.match(r'^\s*\d+\.\s+', line):
        content = process_formatting(re.sub(r'^\s*\d+\.\s+', '', line), keep_comments, url_footnotes)
        return f"\\item {content}"
    
    # Code blocks
    elif line.strip().startswith('```'):
        lang = line.strip()[3:].strip()
        if lang:
            return f"\\begin{{lstlisting}}[language={lang}]"
        else:
            return "\\begin{lstlisting}"
    elif line.strip() == '```':
        return "\\end{lstlisting}\n"
    
    # Regular paragraph content - use process_formatting for consistency
    return process_formatting(line, keep_comments, url_footnotes)

def extract_footnote_definitions(lines, url_footnotes=False):
    """Extract footnote definitions from markdown lines and return processed lines and footnotes"""
    processed_lines = []
    footnotes = {}
    
    for line in lines:
        # Check if this line is a footnote definition: [^id]: content
        footnote_match = re.match(r'^\[\^([^\]]+)\]:\s*(.*)$', line.strip())
        if footnote_match:
            footnote_id = footnote_match.group(1)
            footnote_content = footnote_match.group(2)
            # Process the footnote content for formatting
            processed_content = process_formatting(footnote_content, url_footnotes=url_footnotes)
            footnotes[footnote_id] = processed_content
        else:
            processed_lines.append(line)
    
    return processed_lines, footnotes

def extract_yaml_front_matter(lines):
    """Extract YAML front matter from the beginning of a markdown file"""
    if not lines or not lines[0].strip().startswith('---'):
        return {}, lines
    
    # Find the end of YAML front matter
    end_index = -1
    for i, line in enumerate(lines[1:], 1):
        if line.strip() == '---':
            end_index = i
            break
    
    if end_index == -1:
        return {}, lines
    
    # Extract YAML content
    yaml_lines = lines[1:end_index]
    yaml_content = {}
    
    for line in yaml_lines:
        line = line.strip()
        if ':' in line:
            key, value = line.split(':', 1)
            key = key.strip()
            value = value.strip().strip('"\'')  # Remove quotes
            yaml_content[key] = value
    
    # Return remaining lines (after the closing ---)
    return yaml_content, lines[end_index + 1:]

def convert_markdown_file(md_file_path, use_sections=False, keep_comments=False, url_footnotes=False):
    """Convert a single Markdown file to LaTeX content"""
    with open(md_file_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    # Extract YAML front matter
    yaml_metadata, content_lines = extract_yaml_front_matter(lines)
    
    # Extract footnote definitions
    content_lines, footnotes = extract_footnote_definitions(content_lines, url_footnotes)
    
    latex_content = []
    in_list = False
    in_ordered_list = False
    in_todolist = False
    in_code_block = False
    paragraph_buffer = []
    
    # First, process the entire content to handle multiline HTML comments
    # Strip newlines from content_lines before joining to avoid double newlines
    full_content = '\n'.join(line.rstrip('\n') for line in content_lines)
    full_content = strip_html_comments(full_content, keep_comments)
    content_lines = full_content.split('\n')
    
    for line in content_lines:
        line = line.rstrip()
        
        # Skip empty lines after comment stripping
        if not line.strip():
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            continue
        
        # Handle code blocks
        if line.strip().startswith('```'):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if in_code_block:
                latex_content.append("\\end{lstlisting}\n\n")
                in_code_block = False
            else:
                lang = line.strip()[3:].strip()
                if lang:
                    latex_content.append(f"\\begin{{lstlisting}}[language={lang}]\n")
                else:
                    latex_content.append("\\begin{lstlisting}\n")
                in_code_block = True
            continue
        
        if in_code_block:
            latex_content.append(line + "\n")
            continue
        
        # Handle empty lines
        if not line.strip():
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            continue
        
        # Handle headers
        if line.startswith('#'):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if in_list:
                latex_content.append("\\end{itemize}\n\n")
                in_list = False
            if in_ordered_list:
                latex_content.append("\\end{enumerate}\n\n")
                in_ordered_list = False
            if in_todolist:
                latex_content.append("\\end{todolist}\n\n")
                in_todolist = False
            
            latex_content.append(process_markdown_line(line, use_sections, keep_comments, url_footnotes))
            continue
        
        # Handle blockquotes
        if line.strip().startswith('>'):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if in_list:
                latex_content.append("\\end{itemize}\n\n")
                in_list = False
            if in_ordered_list:
                latex_content.append("\\end{enumerate}\n\n")
                in_ordered_list = False
            if in_todolist:
                latex_content.append("\\end{todolist}\n\n")
                in_todolist = False
            
            latex_content.append(process_markdown_line(line, use_sections, keep_comments, url_footnotes))
            continue
        
        # Handle todolist items
        if re.match(r'^\s*- \[([ x])\]\s+', line):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if not in_todolist:
                if in_list:
                    latex_content.append("\\end{itemize}\n\n")
                    in_list = False
                if in_ordered_list:
                    latex_content.append("\\end{enumerate}\n\n")
                    in_ordered_list = False
                latex_content.append("\\begin{todolist}\n")
                in_todolist = True
            
            latex_content.append(process_markdown_line(line, use_sections, keep_comments, url_footnotes) + "\n")
            continue
        
        # Handle lists
        if line.strip().startswith(('- ', '* ')):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if not in_list:
                if in_ordered_list:
                    latex_content.append("\\end{enumerate}\n\n")
                    in_ordered_list = False
                if in_todolist:
                    latex_content.append("\\end{todolist}\n\n")
                    in_todolist = False
                latex_content.append("\\begin{itemize}\n")
                in_list = True
            
            latex_content.append(process_markdown_line(line, use_sections, keep_comments, url_footnotes) + "\n")
            continue
        
        elif re.match(r'^\s*\d+\.\s+', line):
            if paragraph_buffer:
                latex_content.append(' '.join(paragraph_buffer) + "\n\n")
                paragraph_buffer = []
            
            if not in_ordered_list:
                if in_list:
                    latex_content.append("\\end{itemize}\n\n")
                    in_list = False
                if in_todolist:
                    latex_content.append("\\end{todolist}\n\n")
                    in_todolist = False
                latex_content.append("\\begin{enumerate}\n")
                in_ordered_list = True
            
            latex_content.append(process_markdown_line(line, use_sections, keep_comments, url_footnotes) + "\n")
            continue
        
        # Close lists if we're not in a list item
        if in_list:
            latex_content.append("\\end{itemize}\n\n")
            in_list = False
        if in_ordered_list:
            latex_content.append("\\end{enumerate}\n\n")
            in_ordered_list = False
        if in_todolist:
            latex_content.append("\\end{todolist}\n\n")
            in_todolist = False
        
        # Regular paragraph content
        processed_line = process_markdown_line(line, use_sections, keep_comments, url_footnotes).strip()
        if processed_line:
            paragraph_buffer.append(processed_line)
    
    # Handle remaining content
    if paragraph_buffer:
        latex_content.append(' '.join(paragraph_buffer) + "\n\n")
    
    if in_list:
        latex_content.append("\\end{itemize}\n\n")
    if in_ordered_list:
        latex_content.append("\\end{enumerate}\n\n")
    if in_todolist:
        latex_content.append("\\end{todolist}\n\n")
    
    # Replace footnote placeholders with actual content
    # This is done after all processing to ensure footnotes are properly formatted
    full_content = ''.join(latex_content)
    for footnote_id, footnote_content in footnotes.items():
        placeholder = f'\\footnote{{\\footnotecontent{{{footnote_id}}}}}'
        full_content = full_content.replace(placeholder, f'\\footnote{{{footnote_content}}}')
    
    return full_content

def create_latex_document(md_files, output_file, use_sections=False, title="Your Book Title", author="Author Name", subtitle="Subtitle or Description", novel=False, royal=False, kdp_6x9=False, kdp_trade=False, kdp_mass_market=False, kdp_mass_market_wide=False, minimal=False, keep_comments=False, url_footnotes=False, include_git_info=True, debug_overfull=False):
    """Create the complete LaTeX document using variable-based templates"""
    
    # Get git version information if requested
    git_tag, git_hash, git_date = None, None, None
    if include_git_info and md_files:
        git_tag, git_hash, git_date = get_git_version_info(md_files[0])
    
    # Create version string for display
    version_info = ""
    if git_tag and git_hash:
        version_info = f"{git_tag} ({git_hash})"
    elif git_hash:
        version_info = f"commit {git_hash}"
    
    # Add version info to subtitle if we have it
    if version_info and subtitle:
        subtitle_with_version = f"{subtitle} — {version_info}"
    elif version_info:
        subtitle_with_version = version_info
    else:
        subtitle_with_version = subtitle
    
    if kdp_6x9:
        # KDP 6x9 inch format (152.4 x 228.6mm) optimized for Amazon KDP
        preamble = f'''\\documentclass[12pt,twoside]{{book}}

{FONT_SETUP}

% Page layout for KDP 6x9 inch format (152.4 x 228.6mm)
\\usepackage[
    paperwidth=152.4mm,
    paperheight=228.6mm,
    inner=22mm,      % 0.87in inner margin for spine (KDP minimum + binding clearance)
    outer=16mm,      % 0.63in outer margin (KDP minimum + safety)
    top=20mm,        % 0.79in top margin (KDP minimum + safety)
    bottom=20mm      % 0.79in bottom margin (KDP minimum + safety)
]{{geometry}}

{get_typography_packages(debug_overfull)}

% Paragraph formatting optimized for readability and margin compliance
\\setlength{{\\parindent}}{{12pt}}
\\setlength{{\\parskip}}{{0pt plus 1pt}}
\\setlength{{\\emergencystretch}}{{3em}}  % Allow more flexibility in line breaking
\\setlength{{\\tolerance}}{{9999}}        % Be more tolerant of spacing to avoid overfull lines

% Additional KDP compliance settings
\\setlength{{\\overfullrule}}{{0pt}}      % Don't show overfull boxes
\\setlength{{\\hfuzz}}{{0.5pt}}           % Allow small overfull lines
\\setlength{{\\vfuzz}}{{0.5pt}}           % Allow small overfull lines
\\raggedbottom                            % Don't stretch content to fill pages

% Headers and page numbers for KDP two-sided format
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[LE,RO]{{\\thepage}}
\\fancyhead[LO]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[RE]{{\\nouppercase{{{subtitle_with_version}}}}}
\\renewcommand{{\\headrulewidth}}{{0pt}}
\\setlength{{\\headheight}}{{16pt}}
\\setlength{{\\headsep}}{{8pt}}

{CODE_HIGHLIGHTING_KDP}

{LINKS_REFERENCES_KDP}

{FOOTNOTE_SUPPORT}

% Chapter formatting optimized for KDP
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\Large\\bfseries\\centering}}
{{}}{{0pt}}{{\\Large}}
\\titlespacing*{{\\chapter}}{{0pt}}{{30pt}}{{20pt}}

{TABLE_AND_GRAPHICS}

{LIST_FORMATTING}

{SECTION_NUMBERING}

\\begin{{document}}

% Title page (KDP compliant)
\\begin{{titlepage}}
\\centering
\\vspace*{{3cm}}

{{\\Large\\bfseries {title}}}

\\vspace{{1cm}}

{{\\normalsize {subtitle_with_version}}}

\\vspace{{2cm}}

{{\\normalsize {author}}}

\\vfill

{{\\small\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

'''
        
        # KDP ending (no multicols)
        ending = r'''
\end{document}
'''
    elif kdp_trade:
        # Trade paperback format - 5.5x8.5 inch (13.97 x 21.59cm) optimized for readability
        preamble = f'''\\documentclass[12pt,twoside]{{book}}

{FONT_SETUP}

% Page layout for Trade paperback 5.5x8.5 inch format (13.97 x 21.59cm)
\\usepackage[
    paperwidth=139.7mm,
    paperheight=215.9mm,
    inner=20mm,      % 0.79in inner margin for spine (KDP minimum + binding clearance)
    outer=15mm,      % 0.59in outer margin (KDP minimum + safety)
    top=18mm,        % 0.71in top margin (KDP minimum + safety)
    bottom=18mm      % 0.71in bottom margin (KDP minimum + safety)
]{{geometry}}

{get_typography_packages(debug_overfull)}

% Paragraph formatting optimized for readability and margin compliance
\\setlength{{\\parindent}}{{12pt}}
\\setlength{{\\parskip}}{{0pt plus 1pt}}
\\setlength{{\\emergencystretch}}{{3em}}  % Allow more flexibility in line breaking
\\setlength{{\\tolerance}}{{9999}}        % Be more tolerant of spacing to avoid overfull lines

% Additional KDP compliance settings
\\setlength{{\\overfullrule}}{{0pt}}      % Don't show overfull boxes
\\setlength{{\\hfuzz}}{{0.5pt}}           % Allow small overfull lines
\\setlength{{\\vfuzz}}{{0.5pt}}           % Allow small overfull lines
\\raggedbottom                            % Don't stretch content to fill pages

% Headers and page numbers for trade two-sided format
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[LE,RO]{{\\thepage}}
\\fancyhead[LO]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[RE]{{\\nouppercase{{{subtitle_with_version}}}}}
\\renewcommand{{\\headrulewidth}}{{0pt}}
\\setlength{{\\headheight}}{{16pt}}
\\setlength{{\\headsep}}{{8pt}}

{CODE_HIGHLIGHTING_KDP}

{LINKS_REFERENCES_KDP}

{FOOTNOTE_SUPPORT}

% Chapter formatting optimized for trade paperback
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\Large\\bfseries\\centering}}
{{}}{{0pt}}{{\\Large}}
\\titlespacing*{{\\chapter}}{{0pt}}{{30pt}}{{20pt}}

{TABLE_AND_GRAPHICS}

{LIST_FORMATTING}

{SECTION_NUMBERING}

\\begin{{document}}

% Title page (trade paperback compliant)
\\begin{{titlepage}}
\\centering
\\vspace*{{3cm}}

{{\\Large\\bfseries {title}}}

\\vspace{{1cm}}

{{\\normalsize {subtitle_with_version}}}

\\vspace{{2cm}}

{{\\normalsize {author}}}

\\vfill

{{\\small\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

'''
        
        # Trade ending (no multicols)
        ending = r'''
\end{document}
'''
    elif kdp_mass_market:
        # Mass market paperback format - 5x8 inch (12.7 x 20.32cm) optimized for compact reading
        preamble = f'''\\documentclass[11pt,twoside]{{book}}

{FONT_SETUP}

% Page layout for Mass market paperback 5x8 inch format (12.7 x 20.32cm)
\\usepackage[
    paperwidth=127mm,
    paperheight=203.2mm,
    inner=18mm,      % 0.71in inner margin for spine (KDP minimum + binding clearance)
    outer=14mm,      % 0.55in outer margin (KDP minimum + safety)
    top=20mm,        % 0.79in top margin (increased for header safety)
    bottom=16mm      % 0.63in bottom margin (KDP minimum + safety)
]{{geometry}}

{get_typography_packages(debug_overfull)}

% Paragraph formatting optimized for compact reading and margin compliance
\\setlength{{\\parindent}}{{10pt}}
\\setlength{{\\parskip}}{{0pt plus 1pt}}
\\setlength{{\\emergencystretch}}{{3em}}  % Allow more flexibility in line breaking
\\setlength{{\\tolerance}}{{9999}}        % Be more tolerant of spacing to avoid overfull lines

% Additional KDP compliance settings
\\setlength{{\\overfullrule}}{{0pt}}      % Don't show overfull boxes
\\setlength{{\\hfuzz}}{{0.5pt}}           % Allow small overfull lines
\\setlength{{\\vfuzz}}{{0.5pt}}           % Allow small overfull lines
\\raggedbottom                            % Don't stretch content to fill pages

% Headers and page numbers for mass market two-sided format
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[LE,RO]{{\\thepage}}
\\fancyhead[LO]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[RE]{{\\nouppercase{{{subtitle_with_version}}}}}
\\renewcommand{{\\headrulewidth}}{{0pt}}
\\setlength{{\\headheight}}{{16pt}}
\\setlength{{\\headsep}}{{8pt}}

{CODE_HIGHLIGHTING_KDP}

{LINKS_REFERENCES_KDP}

{FOOTNOTE_SUPPORT}

% Chapter formatting optimized for mass market paperback
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\Large\\bfseries\\centering}}
{{}}{{0pt}}{{\\Large}}
\\titlespacing*{{\\chapter}}{{0pt}}{{25pt}}{{15pt}}

{TABLE_AND_GRAPHICS}

{LIST_FORMATTING}

{SECTION_NUMBERING}

\\begin{{document}}

% Title page (mass market paperback compliant)
\\begin{{titlepage}}
\\centering
\\vspace*{{2.5cm}}

{{\\Large\\bfseries {title}}}

\\vspace{{0.8cm}}

{{\\normalsize {subtitle_with_version}}}

\\vspace{{1.5cm}}

{{\\normalsize {author}}}

\\vfill

{{\\small\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

'''
        
        # Mass market ending (no multicols)
        ending = r'''
\end{document}
'''
    elif kdp_mass_market_wide:
        # Wide mass market paperback format - 5.25x8 inch (13.34 x 20.32cm) optimized for readability
        preamble = f'''\\documentclass[11pt,twoside]{{book}}

{FONT_SETUP}

% Page layout for Wide mass market paperback 5.25x8 inch format (13.34 x 20.32cm)
\\usepackage[
    paperwidth=133.4mm,
    paperheight=203.2mm,
    inner=19mm,      % 0.75in inner margin for spine (KDP minimum + binding clearance)
    outer=14.5mm,    % 0.57in outer margin (KDP minimum + safety)
    top=17mm,        % 0.67in top margin (KDP minimum + safety)
    bottom=17mm      % 0.67in bottom margin (KDP minimum + safety)
]{{geometry}}

{get_typography_packages(debug_overfull)}

% Paragraph formatting optimized for readability and margin compliance
\\setlength{{\\parindent}}{{11pt}}
\\setlength{{\\parskip}}{{0pt plus 1pt}}
\\setlength{{\\emergencystretch}}{{3em}}  % Allow more flexibility in line breaking
\\setlength{{\\tolerance}}{{9999}}        % Be more tolerant of spacing to avoid overfull lines

% Additional KDP compliance settings
\\setlength{{\\overfullrule}}{{0pt}}      % Don't show overfull boxes
\\setlength{{\\hfuzz}}{{0.5pt}}           % Allow small overfull lines
\\setlength{{\\vfuzz}}{{0.5pt}}           % Allow small overfull lines
\\raggedbottom                            % Don't stretch content to fill pages

% Headers and page numbers for wide mass market two-sided format
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[LE,RO]{{\\thepage}}
\\fancyhead[LO]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[RE]{{\\nouppercase{{{subtitle_with_version}}}}}
\\renewcommand{{\\headrulewidth}}{{0pt}}
\\setlength{{\\headheight}}{{16pt}}
\\setlength{{\\headsep}}{{8pt}}

{CODE_HIGHLIGHTING_KDP}

{LINKS_REFERENCES_KDP}

{FOOTNOTE_SUPPORT}

% Chapter formatting optimized for wide mass market paperback
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\Large\\bfseries\\centering}}
{{}}{{0pt}}{{\\Large}}
\\titlespacing*{{\\chapter}}{{0pt}}{{25pt}}{{15pt}}

{TABLE_AND_GRAPHICS}

{LIST_FORMATTING}

{SECTION_NUMBERING}

\\begin{{document}}

% Title page (wide mass market paperback compliant)
\\begin{{titlepage}}
\\centering
\\vspace*{{2.5cm}}

{{\\Large\\bfseries {title}}}

\\vspace{{0.8cm}}

{{\\normalsize {subtitle_with_version}}}

\\vspace{{1.5cm}}

{{\\normalsize {author}}}

\\vfill

{{\\small\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

'''
        
        # Wide mass market ending (no multicols)
        ending = r'''
\end{document}
'''
    elif minimal:
        # Minimal format - clean, simple, no title page or headers (KDP 6x9 inch dimensions)
        preamble = f'''\\documentclass[12pt,oneside]{{article}}

{FONT_SETUP}

% Page layout for minimal format - KDP 6x9 inch format (152.4 x 228.6mm)
\\usepackage[
    paperwidth=152.4mm,
    paperheight=228.6mm,
    left=15mm,       % Left margin
    right=15mm,      % Right margin
    top=19.1mm,      % 0.75in top margin
    bottom=19.1mm    % 0.75in bottom margin
]{{geometry}}

{get_typography_packages(debug_overfull)}

% Paragraph formatting with minimal spacing
\\setlength{{\\parindent}}{{12pt}}
\\setlength{{\\parskip}}{{0pt plus 1pt}}

% Simple page numbers only
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyfoot[C]{{\\thepage}}
\\renewcommand{{\\headrulewidth}}{{0pt}}
\\renewcommand{{\\footrulewidth}}{{0pt}}

{CODE_HIGHLIGHTING_STANDARD}

{LINKS_REFERENCES_STANDARD}

{FOOTNOTE_SUPPORT}

% Simple section formatting for minimal
\\usepackage{{titlesec}}
\\titleformat{{\\section}}
{{\\normalfont\\Large\\bfseries}}
{{\\thesection}}{{1em}}{{}}
\\titlespacing*{{\\section}}{{0pt}}{{12pt}}{{6pt}}

\\titleformat{{\\subsection}}
{{\\normalfont\\large\\bfseries}}
{{\\thesubsection}}{{1em}}{{}}
\\titlespacing*{{\\subsection}}{{0pt}}{{12pt}}{{6pt}}

{TABLE_AND_GRAPHICS}

{LIST_FORMATTING}

\\begin{{document}}

'''
        
        # Minimal ending (no title page, no TOC, no multicols)
        ending = r'''
\end{document}
'''
    elif novel:
        # Single-column novel format (203x127mm, two-sided)
        preamble = f'''\\documentclass[11pt,twoside]{{book}}

{FONT_SETUP}

% Page layout for 203x127mm (8x5in) novel format
\\usepackage[
    paperwidth=127mm,
    paperheight=203mm,
    inner=22mm,      % Inner margin (binding side)
    outer=15mm,      % Outer margin
    top=20mm,        % Top margin
    bottom=20mm      % Bottom margin
]{{geometry}}

{get_typography_packages(debug_overfull)}

% Paragraph formatting with spacing
\\setlength{{\\parindent}}{{12pt}}
\\setlength{{\\parskip}}{{0pt plus 1pt}}

% Headers and page numbers for two-sided novel
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[LE,RO]{{\\thepage}}
\\fancyhead[LO]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[RE]{{\\nouppercase{{{subtitle_with_version}}}}}
\\renewcommand{{\\headrulewidth}}{{0pt}}
\\setlength{{\\headheight}}{{14pt}}

{CODE_HIGHLIGHTING_STANDARD}

{LINKS_REFERENCES_STANDARD}

{FOOTNOTE_SUPPORT}

% Better chapter formatting for novel
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\Large\\bfseries\\centering}}
{{}}{{0pt}}{{\\Large}}
\\titlespacing*{{\\chapter}}{{0pt}}{{30pt}}{{20pt}}

{TABLE_AND_GRAPHICS}

{LIST_FORMATTING}

{SECTION_NUMBERING}

\\begin{{document}}

% Title page
\\begin{{titlepage}}
\\centering
\\vspace*{{3cm}}

{{\\Large\\bfseries {title}}}

\\vspace{{1cm}}

{{\\normalsize {subtitle_with_version}}}

\\vspace{{2cm}}

{{\\normalsize {author}}}

\\vfill

{{\\small\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

'''
        
        # Novel ending (no multicols)
        ending = r'''
\end{document}
'''
        
    elif royal:
        # Single-column royal format (234x156mm, two-sided)
        preamble = f'''\\documentclass[11pt,twoside]{{book}}

{FONT_SETUP}

% Page layout for 234x156mm Royal format
\\usepackage[
    paperwidth=156mm,
    paperheight=234mm,
    inner=25mm,      % Inner margin (binding side)
    outer=18mm,      % Outer margin
    top=22mm,        % Top margin
    bottom=22mm      % Bottom margin
]{{geometry}}

{get_typography_packages(debug_overfull)}

% Paragraph formatting with spacing
\\setlength{{\\parindent}}{{12pt}}
\\setlength{{\\parskip}}{{0pt plus 1pt}}

% Headers and page numbers for two-sided royal
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[LE,RO]{{\\thepage}}
\\fancyhead[LO]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[RE]{{\\nouppercase{{{subtitle_with_version}}}}}
\\renewcommand{{\\headrulewidth}}{{0pt}}
\\setlength{{\\headheight}}{{14pt}}

{CODE_HIGHLIGHTING_STANDARD}

{LINKS_REFERENCES_STANDARD}

{FOOTNOTE_SUPPORT}

% Better chapter formatting for royal
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\Large\\bfseries\\centering}}
{{}}{{0pt}}{{\\Large}}
\\titlespacing*{{\\chapter}}{{0pt}}{{30pt}}{{20pt}}

{TABLE_AND_GRAPHICS}

{LIST_FORMATTING}

{SECTION_NUMBERING}

\\begin{{document}}

% Title page
\\begin{{titlepage}}
\\centering
\\vspace*{{3cm}}

{{\\Large\\bfseries {title}}}

\\vspace{{1cm}}

{{\\normalsize {subtitle_with_version}}}

\\vspace{{2cm}}

{{\\normalsize {author}}}

\\vfill

{{\\small\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

'''
        
        # Royal ending (no multicols)
        ending = r'''
\end{document}
'''
        
    else:
        # Original A4 two-column format
        preamble = f'''\\documentclass[11pt,a4paper,oneside]{{book}}

{FONT_SETUP}

% Page layout optimized for A4 single-sided printing with balanced margins
\\usepackage[
    a4paper,
    left=25mm,     % Left margin
    right=25mm,    % Right margin
    top=25mm,      % Top margin
    bottom=25mm,   % Bottom margin (now equal to top)
    columnsep=12.5mm, % Space between columns (increased for better balance)
    marginparwidth=15mm % Margin notes width
]{{geometry}}

% Two-column layout
\\usepackage{{multicol}}

{get_typography_packages(debug_overfull)}

% Paragraph formatting with spacing
\\setlength{{\\parindent}}{{0pt}}
\\setlength{{\\parskip}}{{6pt plus 2pt minus 1pt}}

% Headers and page numbers
\\usepackage{{fancyhdr}}
\\pagestyle{{fancy}}
\\fancyhf{{}}
\\fancyhead[C]{{\\thepage}}
\\fancyhead[L]{{\\nouppercase{{\\textit{{{title}}}}}}}
\\fancyhead[R]{{\\nouppercase{{{subtitle_with_version}}}}}
\\renewcommand{{\\headrulewidth}}{{0.4pt}}
\\setlength{{\\headheight}}{{14pt}}

{CODE_HIGHLIGHTING_STANDARD}

{LINKS_REFERENCES_STANDARD}

{FOOTNOTE_SUPPORT}

% Better chapter formatting
\\usepackage{{titlesec}}
\\titleformat{{\\chapter}}[display]
{{\\normalfont\\huge\\bfseries\\raggedright}}
{{\\chaptertitlename\\ \\thechapter}}{{20pt}}{{\\Huge}}
\\titlespacing*{{\\chapter}}{{0pt}}{{0pt}}{{40pt}}

{TABLE_AND_GRAPHICS}

{LIST_FORMATTING}

{SECTION_NUMBERING}

\\begin{{document}}

% Title page
\\begin{{titlepage}}
\\centering
\\vspace*{{2cm}}

{{\\Huge\\bfseries {title}}}

\\vspace{{1cm}}

{{\\Large {subtitle_with_version}}}

\\vspace{{2cm}}

{{\\large {author}}}

\\vfill

{{\\large\\today}}

\\end{{titlepage}}

% Table of contents
\\tableofcontents
\\newpage

% Start two-column layout for main content
\\begin{{multicols}}{{2}}

'''

        # A4 two-column ending
        ending = r'''
\end{multicols}
\end{document}
'''

    # Combine everything
    full_content = preamble
    
    # Add title for minimal format using the first filename
    if minimal and md_files:
        first_file = Path(md_files[0])
        file_title = first_file.stem  # filename without extension
        # Convert underscores and hyphens to spaces, capitalize
        file_title = file_title.replace('_', ' ').replace('-', ' ').title()
        
        # Create date string with both actual date and git version
        from datetime import datetime
        current_date = datetime.now().strftime("%B %d, %Y")
        if subtitle_with_version != subtitle:
            # If we have git version info, include both date and version
            date_with_version = f"{current_date} — {subtitle_with_version}"
        else:
            # If no git version, just use the subtitle
            date_with_version = f"{current_date} — {subtitle_with_version}"
        
        full_content += f"\\title{{{file_title}}}\n\\author{{{author}}}\n\\date{{{date_with_version}}}\n\\maketitle\n\n"
    
    for md_file in sorted(md_files):
        print(f"Processing {md_file}...")
        file_content = convert_markdown_file(md_file, use_sections, keep_comments, url_footnotes)
        full_content += file_content + "\n\n"
    
    full_content += ending
    
    # Write to output file
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(full_content)
    
    print(f"LaTeX file created: {output_file}")

def compile_pdf(tex_file):
    """Compile the LaTeX file to PDF using XeLaTeX (required for fontspec)"""
    print("Compiling PDF with XeLaTeX...")
    
    # Get the directory and filename
    tex_dir = os.path.dirname(tex_file) or '.'
    tex_name = os.path.basename(tex_file)
    
    # Run XeLaTeX twice for proper cross-references
    for i in range(2):
        # Clear problematic environment variables that interfere with TeX
        env = os.environ.copy()
        env.pop('TEXMF', None)
        env.pop('TEXMFCNF', None)
        
        result = subprocess.run([
            '/usr/bin/xelatex',  # Use absolute path to avoid Cursor interference
            '-interaction=nonstopmode',
            tex_name
        ], capture_output=True, text=True, cwd=tex_dir, env=env)
        
        if result.returncode != 0:
            print(f"XeLaTeX compilation failed on pass {i+1}:")
            print(result.stdout)
            print(result.stderr)
            return False
        else:
            print(f"XeLaTeX pass {i+1} completed successfully")
    
    return True

def cleanup_latex_files(tex_file, verbose=False):
    """Remove intermediate LaTeX files, keeping only the PDF"""
    base_name = tex_file.replace('.tex', '')
    
    # List of file extensions to remove
    extensions_to_remove = ['.tex', '.aux', '.log', '.out', '.toc']
    removed_files = []
    
    for ext in extensions_to_remove:
        file_to_remove = base_name + ext
        if os.path.exists(file_to_remove):
            try:
                os.remove(file_to_remove)
                removed_files.append(file_to_remove)
                if verbose:
                    print(f"Removed: {file_to_remove}")
            except OSError as e:
                if verbose:
                    print(f"Could not remove {file_to_remove}: {e}")
    
    if verbose and removed_files:
        print(f"Cleanup complete. Removed {len(removed_files)} intermediate files.")
    elif verbose:
        print("No intermediate files to remove.")
    
    return removed_files

def main():
    parser = argparse.ArgumentParser(
        description='Convert Markdown files to a professional book-style PDF'
    )
    parser.add_argument(
        'markdown_files',
        nargs='*',
        help='Markdown files to convert (default: all .md files in current directory)'
    )
    parser.add_argument(
        '-o', '--output',
        default='book.tex',
        help='Output LaTeX file name (default: book.tex, or input filename for single files)'
    )
    parser.add_argument(
        '--no-compile',
        action='store_true',
        help='Generate LaTeX only, do not compile to PDF'
    )
    parser.add_argument(
        '--title',
        default='Your Book Title',
        help='Book title for the title page'
    )
    parser.add_argument(
        '--author',
        default='Author Name',
        help='Author name for the title page'
    )
    parser.add_argument(
        '--subtitle',
        default='Subtitle or Description',
        help='Subtitle for the title page'
    )
    parser.add_argument(
        '--sections',
        action='store_true',
        help='Use sections instead of chapters for # headers (better for shorter documents)'
    )
    parser.add_argument(
        '--novel',
        action='store_true',
        help='Create a single-column, two-sided, 203x127mm format novel'
    )
    parser.add_argument(
        '--royal',
        action='store_true',
        help='Create a single-column, two-sided, 234x156mm format royal'
    )
    parser.add_argument(
        '--kdp-6x9',
        action='store_true',
        help='Create a single-column, 6x9 inch (152.4 x 228.6mm) format optimized for Amazon KDP'
    )
    parser.add_argument(
        '--kdp-trade',
        action='store_true',
        help='Create a single-column, 5.5x8.5 inch (13.97 x 21.59cm) trade paperback format optimized for Amazon KDP'
    )
    parser.add_argument(
        '--kdp-mass-market',
        action='store_true',
        help='Create a single-column, 5x8 inch (12.7 x 20.32cm) mass market paperback format optimized for Amazon KDP'
    )
    parser.add_argument(
        '--kdp-mass-market-wide',
        action='store_true',
        help='Create a single-column, 5.25x8 inch (13.34 x 20.32cm) wide mass market paperback format optimized for Amazon KDP'
    )
    parser.add_argument(
        '-m', '--minimal',
        action='store_true',
        help='Create a minimal PDF without title page, TOC, or headers - just content with page numbers'
    )
    parser.add_argument(
        '-c', '--cleanup',
        action='store_true',
        help='Remove intermediate LaTeX files (.aux, .log, .out, .tex, .toc) after compilation'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Verbose output - list files being processed and removed'
    )
    parser.add_argument(
        '--keep-comments',
        action='store_true',
        help='Keep HTML comments in LaTeX output (convert to LaTeX comments)'
    )
    parser.add_argument(
        '--url-footnotes',
        action='store_true',
        help='Automatically add footnotes with URLs for all links (useful for print documents)'
    )
    parser.add_argument(
        '--debug-overfull',
        action='store_true',
        help='Show overfull hbox warnings during compilation (useful for debugging line breaking issues)'
    )
    
    args = parser.parse_args()
    
    # Find Markdown files
    if args.markdown_files:
        md_files = args.markdown_files
    else:
        md_files = glob.glob('*.md')
    
    if not md_files:
        print("No Markdown files found!")
        sys.exit(1)
    
    # Validate that files are actually markdown
    valid_md_files = []
    for file_path in md_files:
        if is_markdown_file(file_path):
            valid_md_files.append(file_path)
        else:
            print(f"Warning: {file_path} does not appear to be a markdown file (skipping)")
    
    if not valid_md_files:
        print("No valid markdown files found!")
        sys.exit(1)
    
    md_files = valid_md_files
    
    # Set default output filename based on input if not explicitly provided
    if args.output == 'book.tex' and len(md_files) == 1:
        # Extract base name from single input file
        input_path = Path(md_files[0])
        base_name = input_path.stem  # filename without extension
        args.output = f"{base_name}.tex"
    
    print(f"Found {len(md_files)} Markdown files:")
    for f in sorted(md_files):
        print(f"  - {f}")
    
    # Collect metadata from all files
    all_metadata = {}
    for md_file in md_files:
        with open(md_file, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        metadata, _ = extract_yaml_front_matter(lines)
        all_metadata.update(metadata)
    
    # Use command-line args as defaults, but override with YAML metadata if present
    title = all_metadata.get('title', args.title)
    author = all_metadata.get('author', args.author)
    subtitle = all_metadata.get('subtitle', args.subtitle)
    
    # Create the LaTeX document
    # Use sections for novel, royal, KDP, and minimal formats by default
    use_sections = args.sections or args.novel or args.royal or args.kdp_6x9 or args.kdp_trade or args.kdp_mass_market or args.kdp_mass_market_wide or args.minimal
    
    # Automatically enable URL footnotes for print formats
    # These are print formats where URLs should be visible in footnotes
    is_print_format = args.kdp_6x9 or args.kdp_trade or args.kdp_mass_market or args.kdp_mass_market_wide or args.novel or args.royal
    # Default A4 format is also a print format (when no specific format is specified)
    is_default_print_format = not (args.kdp_6x9 or args.kdp_trade or args.kdp_mass_market or args.kdp_mass_market_wide or args.novel or args.royal or args.minimal)
    url_footnotes = args.url_footnotes or is_print_format or is_default_print_format
    
    create_latex_document(md_files, args.output, use_sections, title, author, subtitle, args.novel, args.royal, args.kdp_6x9, args.kdp_trade, args.kdp_mass_market, args.kdp_mass_market_wide, args.minimal, args.keep_comments, url_footnotes, True, args.debug_overfull)
    
    # Optionally compile to PDF
    pdf_created = False
    if not args.no_compile:
        if compile_pdf(args.output):
            pdf_name = args.output.replace('.tex', '.pdf')
            print(f"PDF created successfully: {pdf_name}")
            pdf_created = True
        else:
            print("PDF compilation failed. LaTeX file is still available.")
    
    # Cleanup intermediate files if requested or by default when PDF was created
    if args.cleanup or (pdf_created and not args.no_compile):
        if args.verbose:
            print("\nCleaning up intermediate files...")
        cleanup_latex_files(args.output, args.verbose)
    
    if not pdf_created:
        print("\nTo manually compile the LaTeX file, use:")
        print(f"xelatex {args.output}")
        print("(Run twice for proper cross-references)")

if __name__ == '__main__':
    main()
